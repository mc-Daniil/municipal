# mini-bobry | Medium | Reverse

## Информация

Дорогой друг. Я спокойно шёл по лесу, собирал ягоды и грибы и вдруг встретил кое-что необычное.
Это была семья мини-бобров. Они сказали, что не пропустят меня дальше, пока я не принесу им дерево. Да такое дерево, которое им понравится.
Помоги мне узнать, какое дерево им нужно.

**Вам помогут:** uncompyle6 или pycdc

**Формат флага** - "NMARK{}"

## Выдать участинкам

[main.pyc](public/main.pyc)

## Описание

Обычный .pyc. Сдекомпилить и потихоньку разбираться в проверке флага, которая состоит из 3 частей.

## Решение

1. Используем uncompyle6 или pycdc для декомпиляции байт-кода в исходный код
`pycdc main.pyc -o main.py` - `-o` позволяет задать файл, в который записывается результат
или
`uncompyle6 main.pyc -o main.py` - `-o` позволяет задать файл, в который записывается результат
Так как это был Python 3.7, то uncompyle6 справился лучше
[Исходный код](src/main.py)
2. Ищем код, который начинает выполняться при запуске. Он в строках 67-68. Если запущен именно этот файл, выполняется функция `main_bobr()`
3. В `main_bobr()` видим `try`, `except FileNotFoundError`, `except Exception as e`. Начинает выполняться код в блоке try. Открывается файл `tree.txt` и из него читается строка в переменную `tree`. Если файл не был найден, выполняется блок `except FileNotFoundError`, который выводит сообщение о неудаче, и выполнение завершается. Придругих ошибках выполнение переходит в блок `except Exception as e`, выводится полученное исключение и выполнение завершается.
4. Проверяется, что длина `tree` (А это и есть флаг) равна 52. Иначе сообщение о неудаче
5. Далее вызывается функция `mother_bobr(get_crown(tree))`. В неё передаётся `get_crown(tree)` - содержимое флага до `{`. Функция `mother_bobr()` проверяет, что содержимое флага до `{` - это `NMARK`. Если не так, выводится сообщение о неудаче и выполнение завершается.
6. Далее вызывается функция `older_mini_bobrik(get_trunk(tree))`. В неё передаётся `get_trunk(tree)` - содержимое флага между `{` т `_`. Функция `older_mini_bobrik()` выполняет несколько проверок
   - Длина содержимого равна 20
   - С помощью `encode()` кодирует содержимое в байты. Далее проходится по соответствующим символам байтовых строк `constnant` и `trunk`. Функция ксорит поочерёдно все элементы этих строк и формирует из получившихся байтов новую байтовую строку.
   - Далее с помощью `decode("utf-8")` байты в получившейся строке становятся читаемыми символами
   - Получившаяся строка сравнивается с `C001M1n1B0br1k1W0oow`.
   - Если что-то было не так, выводится сообщение о неудаче и выполнение завершается.
   - Чтобы получить из этих данных содержимое флага, нужно строку `C001M1n1B0br1k1W0oow` поксорить с `constnant`. Код приведён в [solve.py](solve/solve.py)
7. Далее вызывается функция `younger_mini_bobrik(get_root(tree))`. В неё передаётся `get_root(tree)` - содержимое флага между `_` и `}`. Функция `younger_mini_bobrik()` выполняет несколько проверок
   - Длина содержимого равна 24
   - Делит строку на 6 частей по 4 символа
   - Переставляет 4-символьные блоки в порядке, как в списке `indexes = [2, 4, 3, 5, 0, 1]`. То есть сначала идёт второй блок, потом четвёртый и тд.
   - Сравнивает полученный результат со строкой `uuur1B0b1M1nrrssD0N0tHuu`.
   - Чтобы получить содержимое флага, нужно обратно переставить блоки. То есть `uuur` был вторым блоком, `1B0b` был четвёртым блоком и тд. Код приведён в [solve.py](solve/solve.py)
8. Если все проверки пройдены, выводится сообщение об успехе
9. При желании можно протестировать полученный флаг. Для этого нужно в текущей диреткории создать файл `tree.txt` и выполнить `python3 main.pyc` либо `python main.pyc` в зависимости от системы.


## Флаг

`NMARK{W0w1t1sG1ftF0rB0br1k_D0N0tHuuuuur1M1n1B0brrss}`

